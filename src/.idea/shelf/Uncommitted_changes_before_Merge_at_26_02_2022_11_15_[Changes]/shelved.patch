Index: academy/mindswap/server/commands/ReadyHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package academy.mindswap.server.commands;\r\n\r\nimport academy.mindswap.server.Game;\r\nimport academy.mindswap.server.Server;\r\n\r\npublic class ReadyHandler implements CommandHandler{\r\n    @Override\r\n    public void execute(Server server, Server.ClientConnectionHandler clientConnectionHandler) {\r\n        Game game = clientConnectionHandler.getGame();\r\n\r\n        if (game == null){\r\n            clientConnectionHandler.send(\"You can't be ready if you are not in a room.\");\r\n            return;\r\n        }\r\n        if (game.getPlayers().size()==1){\r\n            clientConnectionHandler.send(\"You can't play alone.\");\r\n            return;\r\n        }\r\n\r\n        boolean ready = clientConnectionHandler.isReady() ? false:true;\r\n        clientConnectionHandler.setReady(ready);\r\n\r\n        if(ready) {\r\n            clientConnectionHandler.send(\"You are ready.\");\r\n            server.roomBroadcast(game, clientConnectionHandler.getName(), \"I am ready.\");\r\n        }else{\r\n            clientConnectionHandler.send(\"You are not ready.\");\r\n            server.roomBroadcast(game, clientConnectionHandler.getName(),  \"I am not ready.\");\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/academy/mindswap/server/commands/ReadyHandler.java b/academy/mindswap/server/commands/ReadyHandler.java
--- a/academy/mindswap/server/commands/ReadyHandler.java	(revision c8a45f6d223e67bd9ba208a2e77fbad5d705a50b)
+++ b/academy/mindswap/server/commands/ReadyHandler.java	(date 1645873970393)
@@ -3,7 +3,16 @@
 import academy.mindswap.server.Game;
 import academy.mindswap.server.Server;
 
+/**
+ * A class that represents the command to turn a player ready to the game, that implements CommandHandler.
+ */
 public class ReadyHandler implements CommandHandler{
+    /**
+     * An override method that executes the command to a player .
+     * @param server
+     * @param clientConnectionHandler
+     */
+
     @Override
     public void execute(Server server, Server.ClientConnectionHandler clientConnectionHandler) {
         Game game = clientConnectionHandler.getGame();
Index: academy/mindswap/server/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package academy.mindswap.server;\r\n\r\n\r\nimport academy.mindswap.server.gameCommands.GameCommand;\r\nimport academy.mindswap.server.messages.GameMessages;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * A class that represents the game.\r\n */\r\npublic class Game implements Runnable {\r\n\r\n    //GAME ATTRIBUTES\r\n    private final String roomName;\r\n    private LinkedList<Card> deck;\r\n    private LinkedList<Card> playedCards;\r\n    private List <Server.ClientConnectionHandler> players;\r\n    private Server server;\r\n\r\n    //GAME LOGIC CONTROL BOOLEANS\r\n    private boolean isThereAWinner;\r\n    private boolean playedAtLeastOneCard;\r\n    private boolean canFinishTurn;\r\n    private boolean canPlayAgain;\r\n    private boolean hasToChooseAColor;\r\n    private boolean drewACard;\r\n\r\n    //STORAGE OF ROUND DATA\r\n    private int indexOfPlayerTurn;\r\n    private Card lastCardPlayed;\r\n    private String play;\r\n    private Server.ClientConnectionHandler playerToPlay;\r\n\r\n\r\n    //ACCUMULATORS FOR SPECIAL CARDS\r\n    private int cardsToDraw;\r\n    private int playersToSkip;\r\n\r\n\r\n    /**\r\n     * Game initialized by creating a new card deck.\r\n     */\r\n    public Game(String roomName, Server server) {\r\n        this.roomName = roomName;\r\n        this.server = server;\r\n        createDeck();\r\n        this.players = new ArrayList<>();\r\n    }\r\n\r\n    /**\r\n     * Method that create a deck of cards into a linked list.\r\n     */\r\n    private void createDeck(){\r\n        this.deck = new LinkedList<>();\r\n        this.playedCards = new LinkedList<>();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            deck.add(new Card(CardColors.BLUE,i));\r\n            deck.add(new Card(CardColors.BLUE,i));\r\n            deck.add(new Card(CardColors.GREEN,i));\r\n            deck.add(new Card(CardColors.GREEN,i));\r\n            deck.add(new Card(CardColors.RED,i));\r\n            deck.add(new Card(CardColors.RED,i));\r\n            deck.add(new Card(CardColors.YELLOW,i));\r\n            deck.add(new Card(CardColors.YELLOW,i));\r\n        }\r\n        for (int i=10; i < 13; i++){\r\n            deck.add(new Card(CardColors.BLUE,i));\r\n            deck.add(new Card(CardColors.BLUE,i));\r\n            deck.add(new Card(CardColors.GREEN,i));\r\n            deck.add(new Card(CardColors.GREEN,i));\r\n            deck.add(new Card(CardColors.RED,i));\r\n            deck.add(new Card(CardColors.RED,i));\r\n            deck.add(new Card(CardColors.YELLOW,i));\r\n            deck.add(new Card(CardColors.YELLOW,i));\r\n        }\r\n        for (int i = 0; i < 4; i++) {\r\n            deck.add(new Card(CardColors.BLUE,13));\r\n        }\r\n        Collections.shuffle(this.deck);\r\n    }\r\n\r\n    public void addClient(Server.ClientConnectionHandler clientConnectionHandler){\r\n        this.players.add(clientConnectionHandler);\r\n    }\r\n\r\n    /**\r\n     * Method that starts the game and verify the winner.\r\n     * The game is initialized by setting the deck of the players.\r\n     * While there isn't a winner, the game is running by verifying the player's turn and by validating the draw played.\r\n     */\r\n    @Override\r\n    public void run() {\r\n\r\n        setPlayersDecks();\r\n        lastCardPlayed = getFirstCard();\r\n        resetBooleansAndAccumulators();\r\n\r\n\r\n        while (!isThereAWinner) {\r\n            this.playerToPlay = players.get(indexOfPlayerTurn);\r\n\r\n            if(deck.isEmpty()){\r\n                replaceDeck();\r\n            }\r\n\r\n            playerToPlay.send(playerToPlay.getName() + \" - \" + playerToPlay.getDeck());\r\n            play = waitForPlay();\r\n\r\n            if(isServerCommand(play)){\r\n                playerToPlay.send(\"You can't use a server command inside a game.\");\r\n            }\r\n\r\n            if (isChat(play)){\r\n                continue;\r\n            }\r\n\r\n            play();\r\n            checkIfWinner();\r\n        }\r\n    }\r\n\r\n    private void play(){\r\n        GameCommand gameCommand = GameCommand.getGameCommandFromDescription(play);\r\n\r\n        if (play.matches(\"[0-\" + (playerToPlay.getDeck().size() - 1) + \"]\")) {\r\n            gameCommand = GameCommand.getGameCommandFromDescription(\"play\");\r\n        }\r\n\r\n        if (gameCommand == null) {\r\n            gameCommand = GameCommand.getGameCommandFromDescription(\"NotLegal\");\r\n        }\r\n\r\n        gameCommand.getCommandHandler().execute(this, playerToPlay);\r\n    }\r\n\r\n    public void changeColor(CardColors cardColors){\r\n        lastCardPlayed.setColor(cardColors);\r\n        playerToPlay.send(\"Color changed to \" + cardColors.getDescription());\r\n        server.roomBroadcast(this, playerToPlay.getName(), \"Color changed to \" + cardColors.getDescription());\r\n        hasToChooseAColor=false;\r\n    }\r\n\r\n    public void replaceDeck(){\r\n        Collections.shuffle(this.playedCards);\r\n        this.deck = this.playedCards;\r\n        this.playedCards.clear();\r\n    }\r\n\r\n    public void resetBooleansAndAccumulators(){\r\n        playedAtLeastOneCard = false;\r\n        canFinishTurn=false;\r\n        canPlayAgain = true;\r\n        playersToSkip = 0;\r\n        hasToChooseAColor = false;\r\n        drewACard=false;\r\n    }\r\n\r\n    public boolean hasCardsToDraw(Card card){\r\n        return card.getNumber() != lastCardPlayed.getNumber() && cardsToDraw!=0 && isFirstCardOfTurn() ;\r\n    }\r\n\r\n    public boolean hasCardsToDraw(){\r\n        return cardsToDraw!=0 && isFirstCardOfTurn();\r\n    }\r\n\r\n    public void dealWithPlus4Cards(Card card){\r\n        cardsToDraw+=4;\r\n        cardChangesInDecks(card);\r\n        playerToPlay.send(GameMessages.CHOOSE_COLOR);\r\n        updateBooleans();\r\n        hasToChooseAColor = true;\r\n    }\r\n\r\n    public void cardChangesInDecks(Card card){\r\n        playerToPlay.getDeck().remove(card);\r\n        playerToPlay.send(card.toString());\r\n        server.roomBroadcast(this,playerToPlay.getName(),card.toString());\r\n        this.playedCards.add(lastCardPlayed);\r\n        lastCardPlayed=card;\r\n    }\r\n\r\n    public void updateBooleans(){\r\n        playedAtLeastOneCard = true;\r\n        canFinishTurn = true;\r\n    }\r\n\r\n\r\n    public void dealWithReverse(){\r\n        Server.ClientConnectionHandler p = players.get(indexOfPlayerTurn);\r\n        invertPlayers();\r\n\r\n        Optional<Server.ClientConnectionHandler> playerPlaying = players.stream().filter(player -> player==p).findFirst();\r\n        indexOfPlayerTurn = players.indexOf(playerPlaying.get());\r\n    }\r\n\r\n    private void invertPlayers(){\r\n        int indexToReverse = players.size()-1;\r\n        Server.ClientConnectionHandler[] temp = new Server.ClientConnectionHandler[players.size()];\r\n        for (Server.ClientConnectionHandler p:players) {\r\n            temp[indexToReverse] = p;\r\n            indexToReverse--;\r\n        }\r\n        players = Arrays.stream(temp).collect(Collectors.toList());\r\n    }\r\n\r\n    private boolean isChat(String play){\r\n        return play.startsWith(\"-\");\r\n    }\r\n\r\n    private boolean isServerCommand(String play){\r\n        return play.startsWith(\"/\");\r\n    }\r\n\r\n    private String waitForPlay (){\r\n        while(!playerToPlay.isGameCommandChanged()){\r\n            try {\r\n                Thread.sleep(500);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        playerToPlay.setGameCommandChanged(false);\r\n        return playerToPlay.getMessage();\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Method that set the players deck into an Array List.\r\n     */\r\n    private void setPlayersDecks(){\r\n        this.players.stream().map(player -> player.getDeck()).forEach(playerDeck -> {\r\n            for (int i = 0; i < 5; i++) {\r\n              playerDeck.add(this.deck.poll());\r\n          }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * @return The first card of a player.\r\n     */\r\n    private Card getFirstCard(){\r\n        Card card=this.deck.poll();\r\n        while (card.getNumber()>9){\r\n            this.playedCards.add(card);\r\n            card = deck.poll();\r\n        }\r\n        Server.ClientConnectionHandler playerToPlay = players.get(0);\r\n        playerToPlay.send(card.toString());\r\n        server.roomBroadcast(this,playerToPlay.getName(),card.toString());\r\n        return card;\r\n    }\r\n\r\n    /**\r\n     * Check if a player is a winner, and if it's true validate de boolean parameter.\r\n     * If it's true, prints the winner player.\r\n     */\r\n    private void checkIfWinner(){\r\n        Server.ClientConnectionHandler playerToPlay = players.get(indexOfPlayerTurn);\r\n        if(playerToPlay.getDeck().size()==0){\r\n            isThereAWinner=true;\r\n            playerToPlay.send(GameMessages.THE_WINNER); //here\r\n            server.roomBroadcast(this,playerToPlay.getName(),playerToPlay.getName() + GameMessages.THE_WINNER); //here\r\n        }\r\n    }\r\n\r\n    public void goFishingCards(){\r\n        if (cardsToDraw != 0 && !playedAtLeastOneCard){\r\n            for (int i = 0; i < cardsToDraw; i++) {\r\n                drawCard();\r\n                drewACard=false;\r\n            }\r\n            cardsToDraw = 0;\r\n            canFinishTurn = false;\r\n        }\r\n    }\r\n\r\n    public void drawCard(){\r\n        Card newCard = deck.poll();\r\n        playerToPlay.getDeck().add(newCard);\r\n        playerToPlay.send(GameMessages.YOU_DRAW + newCard);\r\n        server.roomBroadcast(this,playerToPlay.getName(),playerToPlay.getName() + GameMessages.PLAYER_DRAW);\r\n        drewACard=true;\r\n    }\r\n\r\n    public void setNextPlayerToPlay(){\r\n        indexOfPlayerTurn+=playersToSkip;\r\n        indexOfPlayerTurn++;\r\n        if(indexOfPlayerTurn > players.size()-1){\r\n            indexOfPlayerTurn-=players.size();\r\n        }\r\n    }\r\n\r\n    public boolean canPlayACard(){\r\n        return canPlayAgain && !hasToChooseAColor;\r\n    }\r\n\r\n    public boolean isASkipCard(Card card){\r\n        return card.getNumber() == 10;\r\n    }\r\n\r\n    public boolean isAPlus2Card(Card card){\r\n        return card.getNumber() == 11;\r\n    }\r\n\r\n    public boolean isAReverseCard(Card card){\r\n        return card.getNumber() == 12;\r\n    }\r\n\r\n    public boolean isAPlus4Card(Card card){\r\n        return card.getNumber() == 13;\r\n    }\r\n\r\n    public void dealWithSpecialCards(Card card){\r\n        if (isASkipCard(card)){\r\n            playersToSkip++;\r\n        }else if (isAReverseCard(card)){\r\n            dealWithReverse();\r\n        }else if (isAPlus2Card(card)) {\r\n            cardsToDraw+=2;\r\n        }\r\n    }\r\n\r\n    public boolean canDrawACard(){\r\n        return !playedAtLeastOneCard && !drewACard;\r\n    }\r\n\r\n    public boolean canPlayAPlus4Card() {\r\n        return lastCardPlayed.getNumber() == 13 || isFirstCardOfTurn();\r\n    }\r\n\r\n    //GETTERS\r\n\r\n    public String getRoomName() {\r\n        return roomName;\r\n    }\r\n\r\n    public List<Server.ClientConnectionHandler> getPlayers() {\r\n        return players;\r\n    }\r\n\r\n    public Card getLastCardPlayed() {\r\n        return lastCardPlayed;\r\n    }\r\n\r\n    public Server getServer() {\r\n        return server;\r\n    }\r\n\r\n    public Boolean getHasToChooseAColor() {\r\n        return hasToChooseAColor;\r\n    }\r\n\r\n    public boolean isFirstCardOfTurn() {\r\n        return !playedAtLeastOneCard;\r\n    }\r\n\r\n    public boolean canFinishTurn() {\r\n        return canFinishTurn;\r\n    }\r\n\r\n    public String getPlay() {\r\n        return play;\r\n    }\r\n\r\n    public Server.ClientConnectionHandler getPlayerToPlay() {\r\n        return playerToPlay;\r\n    }\r\n\r\n    //SETTERS\r\n\r\n    public void setCardsToDraw(int cardsToDraw) {\r\n        this.cardsToDraw = cardsToDraw;\r\n    }\r\n\r\n    public void setServer(Server server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setCanFinishTurn(boolean canFinishTurn) {\r\n        this.canFinishTurn = canFinishTurn;\r\n    }\r\n\r\n    public void setCanPlayAgain(boolean canPlayAgain) {\r\n        this.canPlayAgain = canPlayAgain;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/academy/mindswap/server/Game.java b/academy/mindswap/server/Game.java
--- a/academy/mindswap/server/Game.java	(revision c8a45f6d223e67bd9ba208a2e77fbad5d705a50b)
+++ b/academy/mindswap/server/Game.java	(date 1645874121785)
@@ -158,6 +158,11 @@
         drewACard=false;
     }
 
+    /**
+     * Method that
+     * @param card
+     * @return
+     */
     public boolean hasCardsToDraw(Card card){
         return card.getNumber() != lastCardPlayed.getNumber() && cardsToDraw!=0 && isFirstCardOfTurn() ;
     }
@@ -226,8 +231,6 @@
         return playerToPlay.getMessage();
     }
 
-
-
     /**
      * Method that set the players deck into an Array List.
      */
Index: academy/mindswap/server/commands/QuitRoomHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package academy.mindswap.server.commands;\r\n\r\nimport academy.mindswap.server.Game;\r\nimport academy.mindswap.server.Server;\r\nimport academy.mindswap.server.messages.Messages;\r\n\r\n/**\r\n * A class that represents the command to one player leave the room, that implements CommandHandler.\r\n */\r\npublic class QuitRoomHandler implements CommandHandler {\r\n\r\n    /**\r\n     * An override method that executes the command to a player leave/quit the room.\r\n     * @param server\r\n     * @param clientConnectionHandler\r\n     */\r\n    @Override\r\n    public void execute(Server server, Server.ClientConnectionHandler clientConnectionHandler) {\r\n        String message = clientConnectionHandler.getMessage();\r\n        String room = clientConnectionHandler.getGame().getRoomName();\r\n        Game game = clientConnectionHandler.getGame();\r\n\r\n        clientConnectionHandler.setGame(null);\r\n        game.getPlayers().remove(clientConnectionHandler);\r\n        server.getClientsOnGeneral().add(clientConnectionHandler);\r\n        server.roomBroadcast(game, clientConnectionHandler.getName(), Messages.PLAYER_QUIT_ROOM);\r\n        server.broadcast(clientConnectionHandler.getName(), \" Entered in the lobby.\");\r\n        if (game.getPlayers().isEmpty()){\r\n            server.getOpenGames().remove(game);\r\n            return;\r\n        }\r\n\r\n        for (Server.ClientConnectionHandler player: game.getPlayers()) {\r\n            player.setReady(false);\r\n            player.send(\"Someone left the room and you became unready.\");\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/academy/mindswap/server/commands/QuitRoomHandler.java b/academy/mindswap/server/commands/QuitRoomHandler.java
--- a/academy/mindswap/server/commands/QuitRoomHandler.java	(revision c8a45f6d223e67bd9ba208a2e77fbad5d705a50b)
+++ b/academy/mindswap/server/commands/QuitRoomHandler.java	(date 1645873970444)
@@ -11,8 +11,8 @@
 
     /**
      * An override method that executes the command to a player leave/quit the room.
-     * @param server
-     * @param clientConnectionHandler
+     * @param server The server.
+     * @param clientConnectionHandler The player.
      */
     @Override
     public void execute(Server server, Server.ClientConnectionHandler clientConnectionHandler) {
